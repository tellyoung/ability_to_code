class Solution:
    def findRepeatNumber(self, nums: List[int]) -> int:
        d = {}
        for i in nums:
            if i not in d:
                d[i] = 1
            else:
                d[i] += 1
                if d[i] >= 2:
                    break
        return i


方法三：把数组视为哈希表（有一类问题是这么做的，但是会修改数组）
由于数组元素的值都在指定的范围内，这个范围恰恰好与数组的下标可以一一对应；
因此看到数值，就可以知道它应该放在什么位置，这里数字nums[i] 应该放在下标为 i 的位置上，这就像是我们人为编写了哈希函数，这个哈希函数的规则还特别简单；
而找到重复的数就是发生了哈希冲突；

类似问题还有「力扣」第 41 题： 缺失的第一个正数、「力扣」第 442 题： 数组中重复的数据、「力扣」第 448 题： 找到所有数组中消失的数字 。
分析：这个思路利用到了数组的元素值的范围恰好和数组的长度是一样的，因此数组本身可以当做哈希表来用。遍历一遍就可以找到重复值，但是修改了原始数组。

class Solution:

    def findRepeatNumber(self, nums: List[int]) -> int:
        for index, value in enumerate(nums):

            while index != value:
                if nums[value] == value:
                    return value

                nums[value], nums[index] = nums[index], nums[value]
        return -1


复杂度分析：

时间复杂度：O(N)O(N)，这里 NN 是数组的长度。虽然 for 循环里面套了 while，但是每一个数来到它应该在的位置以后，位置就不会再变化。这里用到的是均摊复杂度分析的方法：如果在某一个位置 while 循环体执行的次数较多，那么一定在后面的几个位置，根本不会执行 while 循环体内的代码，也就是说最坏的情况不会一直出现。也就是说最坏复杂度的情况不会一直出现。
空间复杂度：O(1)O(1)。



方法四：二分法（为了不修改数组，要遍历数组很多遍）
由于要确定的数字是有范围的整数，因此可以使用二分法来确定这个数，这就是「力扣」第 278 题：“寻找重复数”，题目有一点点不一样，但思想是一样。

分析：这种做法，不修改原始数组，不使用额外空间（即不像使用哈希表的方法那样，使用 O(N)O(N) 空间），但是看了数组很多遍，是很反常的“使用时间换空间”的做法。

「力扣」第 278 题：“寻找重复数”，还有一种做法是快慢指针，就更难想到了，这里只是做提示，大家可以在这道题的题解区和评论去看到这种解法，这里就不展开了。
